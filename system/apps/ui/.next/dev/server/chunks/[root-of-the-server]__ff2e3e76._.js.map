{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/sb/Dev/chirostretch/src/app/api/gravity-forms/submit/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\n\n// Ensure this route is dynamic\nexport const dynamic = \"force-dynamic\";\nexport const runtime = \"nodejs\";\n\nconst GRAPHQL_ENDPOINT = process.env.NEXT_PUBLIC_WPGRAPHQL_ENDPOINT;\n\n// Field types that need special value mapping\nconst EMAIL_FIELD_TYPES = [\"EMAIL\"];\nconst CONSENT_FIELD_TYPES = [\"CONSENT\"];\nconst CHECKBOX_FIELD_TYPES = [\"CHECKBOX\"];\nconst NAME_FIELD_TYPES = [\"NAME\"];\n\ntype NameValues = {\n  first?: string;\n  last?: string;\n  middle?: string;\n  prefix?: string;\n  suffix?: string;\n};\n\ntype FieldValueInput = {\n  id: number;\n  value?: string;\n  values?: string[];\n  emailValues?: { value: string; confirmationValue?: string };\n  checkboxValues?: Array<{ inputId: number; value: string }>;\n  nameValues?: NameValues;\n};\n\n// Extract numeric field ID from key (handles both numeric IDs and base64 GraphQL IDs)\nfunction extractFieldId(key: string): number | null {\n  // If already numeric\n  const numericId = parseInt(key, 10);\n  if (!isNaN(numericId)) {\n    return numericId;\n  }\n\n  // Try to decode base64 GraphQL ID (format: gf_form_field:formId:fieldId)\n  try {\n    const decoded = Buffer.from(key, \"base64\").toString(\"utf-8\");\n    const parts = decoded.split(\":\");\n    if (parts.length === 3 && parts[0] === \"gf_form_field\") {\n      const fieldId = parseInt(parts[2], 10);\n      if (!isNaN(fieldId)) {\n        return fieldId;\n      }\n    }\n  } catch {\n    // Not a valid base64 string\n  }\n\n  return null;\n}\n\n// Transform form data object to GraphQL fieldValues array\nfunction transformFormDataToFieldValues(\n  formData: Record<string, unknown>,\n  fieldTypes?: Record<string, string>\n): FieldValueInput[] {\n  return Object.entries(formData)\n    .map(([key, value]) => {\n      const fieldId = extractFieldId(key);\n      if (fieldId === null) return null;\n\n      const fieldType = fieldTypes?.[key]?.toUpperCase();\n\n      // Handle email fields\n      if (fieldType && EMAIL_FIELD_TYPES.includes(fieldType)) {\n        return {\n          id: fieldId,\n          emailValues: { value: String(value || \"\") },\n        } as FieldValueInput;\n      }\n\n      // Handle consent fields - single checkbox with value \"1\"\n      if (fieldType && CONSENT_FIELD_TYPES.includes(fieldType)) {\n        const isChecked = value === \"1\" || value === true;\n        return {\n          id: fieldId,\n          checkboxValues: isChecked\n            ? [{ inputId: parseFloat(`${fieldId}.1`), value: \"1\" }]\n            : [],\n        } as FieldValueInput;\n      }\n\n      // Handle checkbox fields (array of selected values)\n      if (fieldType && CHECKBOX_FIELD_TYPES.includes(fieldType)) {\n        const valuesArray = Array.isArray(value) ? value : value ? [value] : [];\n        const checkboxValues = valuesArray.map((v, index) => ({\n          inputId: parseFloat(`${fieldId}.${index + 1}`),\n          value: String(v),\n        }));\n        return {\n          id: fieldId,\n          checkboxValues,\n        } as FieldValueInput;\n      }\n\n      // Handle name fields\n      if (fieldType && NAME_FIELD_TYPES.includes(fieldType)) {\n        // Value could be an object with first/last or a simple string\n        if (typeof value === \"object\" && value !== null) {\n          const nameObj = value as Record<string, unknown>;\n          return {\n            id: fieldId,\n            nameValues: {\n              first: String(nameObj.first || \"\"),\n              last: String(nameObj.last || \"\"),\n              middle: nameObj.middle ? String(nameObj.middle) : undefined,\n              prefix: nameObj.prefix ? String(nameObj.prefix) : undefined,\n              suffix: nameObj.suffix ? String(nameObj.suffix) : undefined,\n            },\n          } as FieldValueInput;\n        }\n        // Simple string - treat as first name only\n        return {\n          id: fieldId,\n          nameValues: {\n            first: String(value || \"\"),\n          },\n        } as FieldValueInput;\n      }\n\n      // Handle arrays (multi-select, etc.)\n      if (Array.isArray(value)) {\n        return {\n          id: fieldId,\n          values: value.map(String),\n        } as FieldValueInput;\n      }\n\n      // Default: simple value field\n      return {\n        id: fieldId,\n        value: String(value || \"\"),\n      } as FieldValueInput;\n    })\n    .filter((item): item is FieldValueInput => item !== null);\n}\n\nexport async function GET() {\n  return NextResponse.json({\n    message: \"Gravity Forms submit endpoint. Use POST to submit forms.\",\n  });\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { formId, formData, fieldTypes } = body;\n\n    if (!formId || !formData) {\n      return NextResponse.json(\n        { message: \"Form ID and form data are required.\" },\n        { status: 400 }\n      );\n    }\n\n    if (!GRAPHQL_ENDPOINT) {\n      return NextResponse.json(\n        { message: \"GraphQL endpoint is not configured.\" },\n        { status: 500 }\n      );\n    }\n\n    // Transform form data to GraphQL fieldValues format\n    const fieldValues = transformFormDataToFieldValues(formData, fieldTypes);\n\n    // GraphQL mutation for form submission\n    const mutation = `\n      mutation SubmitGfForm($id: ID!, $fieldValues: [FormFieldValuesInput]!) {\n        submitGfForm(input: { id: $id, fieldValues: $fieldValues }) {\n          errors {\n            id\n            message\n          }\n          entry {\n            ... on GfSubmittedEntry {\n              databaseId\n            }\n          }\n          confirmation {\n            type\n            message\n            url\n          }\n        }\n      }\n    `;\n\n    const response = await fetch(GRAPHQL_ENDPOINT, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        query: mutation,\n        variables: {\n          id: String(formId),\n          fieldValues,\n        },\n      }),\n    });\n\n    const result = await response.json();\n\n    // Check for GraphQL errors\n    if (result.errors && result.errors.length > 0) {\n      console.error(\"GraphQL errors:\", result.errors);\n      return NextResponse.json(\n        {\n          is_valid: false,\n          message: result.errors[0]?.message || \"Failed to submit form.\",\n          errors: result.errors,\n        },\n        { status: 400 }\n      );\n    }\n\n    // Check for form validation errors\n    const submitResult = result.data?.submitGfForm;\n    if (submitResult?.errors && submitResult.errors.length > 0) {\n      // Transform GF GraphQL errors to the format expected by error mapper\n      const validationMessages: Record<string, string> = {};\n      for (const error of submitResult.errors) {\n        if (error.id) {\n          validationMessages[error.id] = error.message;\n        }\n      }\n\n      return NextResponse.json(\n        {\n          is_valid: false,\n          validation_messages: validationMessages,\n          message: \"Please correct the errors below.\",\n        },\n        { status: 400 }\n      );\n    }\n\n    // Success\n    const confirmation = submitResult?.confirmation;\n    return NextResponse.json({\n      success: true,\n      message: \"Form submitted successfully.\",\n      confirmation_message: confirmation?.message || \"Thank you for your submission!\",\n      confirmation_type: confirmation?.type,\n      confirmation_url: confirmation?.url,\n      entry_id: submitResult?.entry?.databaseId,\n    });\n  } catch (error) {\n    console.error(\"Form submission error:\", error);\n    return NextResponse.json(\n      {\n        message:\n          error instanceof Error\n            ? error.message\n            : \"An error occurred while submitting the form.\",\n      },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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"}}]
}