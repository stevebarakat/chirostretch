{
  "version": 3,
  "sources": ["../src/util/ast.js", "../src/util/react.js", "../src/rules/no-empty-effect.js", "../src/rules/no-adjust-state-on-prop-change.js", "../src/rules/no-reset-all-state-on-prop-change.js", "../src/rules/no-event-handler.js", "../src/rules/no-pass-live-state-to-parent.js", "../src/rules/no-initialize-state.js", "../src/rules/no-chain-state-updates.js", "../src/rules/no-derived-state.js", "../src/rules/no-pass-data-to-parent.js", "../src/rules/no-pass-ref-to-parent.js", "../src/index.js", "../src/index.cjs"],
  "sourcesContent": ["/**\n * @import {Scope,Rule} from 'eslint'\n */\n\n/**\n * Get all references that ultimately flow into `ref`.\n *\n * @param {Rule.RuleContext} context\n * @param {Scope.Reference} ref\n * @param {\"leaf\" | \"all\"} [mode=\"all\"]\n * @param {Set<Scope.Reference>} visited\n *\n * @returns {Scope.Reference[]}\n */\nexport const getUpstreamRefs = (\n  context,\n  ref,\n  mode = \"all\",\n  visited = new Set(),\n) => {\n  // TODO: Probably best to track this here but let the downstream `traverse()` handle it?\n  // Especially if we can simplify/eliminate `getDownstreamRefs()` -> `findDownstreamNodes()` from the path.\n  visited.add(ref);\n\n  const upstreamRefs = ref.resolved?.defs\n    // We have no analytical use for import statements; terminate at the previous reference (actually using the imported thing).\n    .filter((def) => def.type !== \"ImportBinding\")\n    // Don't traverse parameter definitions.\n    // Their definition node is the function, so downstream would include the whole function body.\n    .filter((def) => def.type !== \"Parameter\")\n    // `def.node.init` is for ArrowFunctionExpression, VariableDeclarator, (etc?).\n    // `def.node.body` is for FunctionDeclaration.\n    .map((def) => def.node.init ?? def.node.body)\n    .filter(Boolean)\n    .flatMap((node) => getDownstreamRefs(context, node))\n    // Prevent infinite recursion from circular references.\n    .filter((ref) => !visited.has(ref))\n    .flatMap((ref) => getUpstreamRefs(context, ref, mode, visited));\n\n  const isLeafRef =\n    // Unresolvable references (e.g. missing imports, misconfigured globals).\n    upstreamRefs === undefined ||\n    // Actually terminal references (e.g. parameters, imports, globals).\n    upstreamRefs.length === 0;\n\n  return mode === \"leaf\"\n    ? isLeafRef\n      ? [ref]\n      : upstreamRefs\n    : [ref].concat(upstreamRefs ?? []);\n  // We don't care to analyze non-prop parameters.\n  // They are local to the function and essentially duplicate the argument reference.\n  // NOTE: Okay to return them while we use `some()` on the result.\n  // .filter(\n  //   (ref) =>\n  //     isProp(ref) ||\n  //     !ref.resolved ||\n  //     ref.resolved.defs.some((def) => def.type !== \"Parameter\"),\n  // )\n};\n\n/**\n * Descend the AST from `node`, calling `visit` on each node.\n *\n * @param {Rule.RuleContext} context\n * @param {Rule.Node} node\n * @param {(node: Rule.Node) => void} visit\n * @param {Set<Rule.Node>} visited\n */\nexport const descend = (context, node, visit, visited = new Set()) => {\n  if (visited.has(node)) {\n    return;\n  }\n  visit(node);\n  visited.add(node);\n\n  (context.sourceCode.visitorKeys[node.type] || [])\n    .map((key) => node[key])\n    // Some `visitorKeys` are optional, e.g. `IfStatement.alternate`.\n    .filter(Boolean)\n    // Can be an array, like `CallExpression.arguments`\n    .flatMap((child) => (Array.isArray(child) ? child : [child]))\n    // Can rarely be `null`, e.g. `ArrayPattern.elements[1]` when an element is skipped - `const [a, , b] = arr`\n    .filter(Boolean)\n    // Check it's a valid AST node\n    .filter((child) => typeof child.type === \"string\")\n    .forEach((child) => descend(context, child, visit, visited));\n};\n\n/**\n * @param {Rule.RuleContext} context\n * @param {Rule.Node} topNode\n * @param {string} type\n */\nexport const findDownstreamNodes = (context, topNode, type) => {\n  const nodes = [];\n  descend(context, topNode, (node) => {\n    if (node.type === type) {\n      nodes.push(node);\n    }\n  });\n  return nodes;\n};\n\n/**\n * @param {Rule.RuleContext} context\n * @param {Rule.Node} node\n */\nexport const getDownstreamRefs = (context, node) =>\n  findDownstreamNodes(context, node, \"Identifier\")\n    .map((identifier) => getRef(context, identifier))\n    .filter(Boolean);\n\n/**\n * @param {Scope.Reference} ref\n * @param {Rule.Node} current\n * @returns {Rule.Node | undefined}\n */\nexport const getCallExpr = (ref, current = ref.identifier.parent) => {\n  if (current.type === \"CallExpression\") {\n    // We've reached the top - confirm that the ref is the (eventual) callee, as opposed to an argument.\n    let node = ref.identifier;\n    while (node.parent.type === \"MemberExpression\") {\n      node = node.parent;\n    }\n\n    if (current.callee === node) {\n      return current;\n    }\n  }\n\n  if (current.type === \"MemberExpression\") {\n    return getCallExpr(ref, current.parent);\n  }\n\n  return undefined;\n};\n\n/**\n * When using this, we assume that args passed to the derived function are always eventually passed to underlying functions.\n * Which they may not be. Would be better to trace the actual flow of values, but that's complex. We'll start with this for now.\n *\n * @param {Rule.RuleContext} context\n * @param {Scope.Reference} ref\n * @param {\"leaf\" | \"all\"} [mode=\"all\"] Whether to return all refs, or only leaf refs. Note that \"all\" includes `ref` itself.\n * @returns {Rule.Node[]}\n */\nexport const getArgsUpstreamRefs = (context, ref, mode) =>\n  getUpstreamRefs(context, ref, mode)\n    .map((ref) => getCallExpr(ref))\n    .filter(Boolean)\n    .flatMap((callExpr) => callExpr.arguments)\n    .flatMap((arg) => getDownstreamRefs(context, arg))\n    .flatMap((ref) => getUpstreamRefs(context, ref));\n\n/**\n * Walks up the AST until `within` (returns `true`) or finding any of (returns `false`):\n * - An `async` function\n * - A function declaration, which may be called at an arbitrary later time.\n *   - While we return false for *this* call, we may still return true for a call to a function containing this call. Combined with `getUpstreamRefs()`, it will still flag calls to the containing function.\n * - A function passed as a callback to another function or `new` - event handler, `setTimeout`, `Promise.then()` `new ResizeObserver()`, etc.\n *\n * Inspired by https://eslint-react.xyz/docs/rules/hooks-extra-no-direct-set-state-in-use-effect\n *\n * @param {Rule.Node} node\n * @param {Rule.Node} within\n * @returns {boolean}\n */\nexport const isSynchronous = (node, within) => {\n  if (node == within) {\n    // Reached the top without finding any blocking conditions\n    return true;\n  } else if (\n    // Obviously not immediate if async. I think this never occurs in isolation from the below conditions? But just in case for now.\n    node.async ||\n    // Present when calling externally-defined async functions (`node.async` is only true on the function definition).\n    // We'll play it safe and assume that any state, props, etc. used in this function or its upstreams may be used asynchronously.\n    node.type === \"AwaitExpression\" ||\n    (node.type === \"UnaryExpression\" && node.operator === \"void\") ||\n    // Inside a named or anonymous function that may be called later, either as a callback or by the developer.\n    node.type === \"FunctionDeclaration\" ||\n    node.type === \"FunctionExpression\" ||\n    node.type === \"ArrowFunctionExpression\"\n  ) {\n    return false;\n  } else {\n    // Keep going up\n    return isSynchronous(node.parent, within);\n  }\n};\n\n/**\n * @param {Rule.RuleContext} context\n * @param {Rule.Node} identifier\n *\n * @returns {Scope.Reference | undefined}\n */\nexport const getRef = (context, identifier) =>\n  context.sourceCode\n    .getScope(identifier)\n    ?.references.find((ref) => ref.identifier == identifier);\n\n/**\n * @param {Rule.RuleContext} context\n * @param {Scope.Reference} ref\n * @param {(ref: Scope.Reference) => boolean} predicate\n * @returns {boolean} Whether this reference eventually calls a function matching the given predicate.\n */\nexport const isEventualCallTo = (context, ref, predicate) =>\n  getCallExpr(ref) !== undefined &&\n  getUpstreamRefs(context, ref).some(predicate);\n", "import { getDownstreamRefs, getUpstreamRefs, isEventualCallTo } from \"./ast.js\";\n\n/**\n * @import {Scope,Rule} from 'eslint'\n */\n\n/**\n * @param {Rule.Node} node\n * @returns {boolean}\n */\nexport const isReactFunctionalComponent = (node) =>\n  (node.type === \"FunctionDeclaration\" ||\n    (node.type === \"VariableDeclarator\" &&\n      (node.init.type === \"ArrowFunctionExpression\" ||\n        node.init.type === \"CallExpression\"))) &&\n  node.id.type === \"Identifier\" &&\n  node.id.name[0].toUpperCase() === node.id.name[0];\n\n/**\n * Excludes known pure HOCs like `memo` and `forwardRef`.\n * Basically this is meant to detect custom HOCs that may have side effects, particularly when using their props.\n *\n * TODO: Will not detect when the component is defined normally and then exported wrapped in an HOC.\n * e.g. `const MyComponent = (props) => {...}; export default memo(MyComponent);`\n *\n * @param {Rule.Node} node\n * @returns {boolean}\n */\nexport const isReactFunctionalHOC = (node) =>\n  node.type === \"VariableDeclarator\" &&\n  node.init &&\n  node.init.type === \"CallExpression\" &&\n  node.init.callee.type === \"Identifier\" &&\n  ![\"memo\", \"forwardRef\"].includes(node.init.callee.name) &&\n  node.init.arguments.length > 0 &&\n  (node.init.arguments[0].type === \"ArrowFunctionExpression\" ||\n    node.init.arguments[0].type === \"FunctionExpression\") &&\n  node.id.type === \"Identifier\" &&\n  node.id.name[0].toUpperCase() === node.id.name[0];\n\n/**\n * @param {Rule.Node} node\n * @returns {boolean}\n */\nexport const isCustomHook = (node) =>\n  (node.type === \"FunctionDeclaration\" ||\n    (node.type === \"VariableDeclarator\" &&\n      node.init &&\n      (node.init.type === \"ArrowFunctionExpression\" ||\n        node.init.type === \"FunctionExpression\"))) &&\n  node.id.type === \"Identifier\" &&\n  node.id.name.startsWith(\"use\") &&\n  node.id.name[3] === node.id.name[3].toUpperCase();\n\n/**\n * @param {Rule.Node} node\n * @returns {boolean}\n */\nexport const isUseState = (node) =>\n  (node.type === \"Identifier\" && node.name === \"useState\") ||\n  (node.type === \"MemberExpression\" &&\n    node.object.name === \"React\" &&\n    node.property.name === \"useState\") ||\n  // Support passing `ref.identifier` directly for convenience\n  (node.parent.type === \"MemberExpression\" &&\n    node.parent.object.name === \"React\" &&\n    node.parent.property.name === \"useState\");\n\n/**\n * @param {Scope.Reference} ref\n * @returns {boolean}\n */\nexport const isState = (ref) =>\n  ref.resolved?.defs.some(\n    (def) =>\n      def.node.type === \"VariableDeclarator\" &&\n      def.node.init?.type === \"CallExpression\" &&\n      isUseState(def.node.init.callee) &&\n      def.node.id.type === \"ArrayPattern\" &&\n      (def.node.id.elements.length === 1 ||\n        def.node.id.elements.length === 2) &&\n      def.node.id.elements[0]?.type === \"Identifier\" &&\n      def.node.id.elements[0].name === ref.identifier.name,\n  );\n\n/**\n * @param {Scope.Reference} ref\n * @returns {boolean}\n */\nexport const isStateSetter = (ref) =>\n  ref.resolved?.defs.some(\n    (def) =>\n      def.node.type === \"VariableDeclarator\" &&\n      def.node.init?.type === \"CallExpression\" &&\n      isUseState(def.node.init.callee) &&\n      def.node.id.type === \"ArrayPattern\" &&\n      def.node.id.elements.length === 2 &&\n      def.node.id.elements[1]?.type === \"Identifier\" &&\n      def.node.id.elements[1].name === ref.identifier.name,\n  );\n\n/**\n * Returns false for props of HOCs (e.g. `withRouter`) because they usually have side effects.\n *\n * @param {Scope.Reference} ref\n * @returns {boolean}\n */\nexport const isProp = (ref) =>\n  ref.resolved?.defs.some((def) => {\n    const declaringNode =\n      def.node.type === \"ArrowFunctionExpression\"\n        ? def.node.parent.type === \"CallExpression\"\n          ? def.node.parent.parent\n          : def.node.parent\n        : def.node;\n    return (\n      def.type === \"Parameter\" &&\n      ((isReactFunctionalComponent(declaringNode) &&\n        !isReactFunctionalHOC(declaringNode)) ||\n        isCustomHook(declaringNode))\n    );\n  });\n\n/**\n * @param {Scope.Reference} ref\n * @returns {boolean}\n */\nexport const isConstant = (ref) =>\n  (ref.resolved?.defs ?? []).some(\n    (def) =>\n      (def.node.type === \"VariableDeclarator\" &&\n        def.node.init?.type === \"Literal\") ||\n      def.node.init?.type === \"TemplateLiteral\" ||\n      def.node.init?.type === \"ArrayExpression\" ||\n      def.node.init?.type === \"ObjectExpression\",\n  );\n\n/**\n * @param {Scope.Reference} ref\n * @returns {boolean}\n */\nexport const isUseRef = (ref) =>\n  (ref.identifier.type === \"Identifier\" && ref.identifier.name === \"useRef\") ||\n  (ref.identifier.parent.type === \"MemberExpression\" &&\n    ref.identifier.parent.object.name === \"React\" &&\n    ref.identifier.parent.property.name === \"useRef\");\n\n/**\n * @param {Scope.Reference} ref\n * @returns {boolean}\n */\nexport const isRef = (ref) =>\n  ref.resolved?.defs.some(\n    (def) =>\n      def.node.type === \"VariableDeclarator\" &&\n      def.node.init?.type === \"CallExpression\" &&\n      ((def.node.init.callee.type === \"Identifier\" &&\n        def.node.init.callee.name === \"useRef\") ||\n        (def.node.init.callee.type === \"MemberExpression\" &&\n          def.node.init.callee.object.name === \"React\" &&\n          def.node.init.callee.property.name === \"useRef\")),\n  );\n\n/**\n * Whether the reference's `current` property is being accessed.\n * Heuristic for whether the reference is a React ref object.\n * Because we don't always have access to the `useRef` call itself.\n * For example when receiving a ref from props.\n *\n * @param {Scope.Reference} ref\n * @returns {boolean}\n */\nexport const isRefCurrent = (ref) =>\n  ref.identifier.parent.type === \"MemberExpression\" &&\n  ref.identifier.parent.property.type === \"Identifier\" &&\n  ref.identifier.parent.property.name === \"current\";\n\n/**\n * Does not include `useLayoutEffect`.\n * When used correctly, it interacts with the DOM = external system = (probably) valid effect.\n * When used incorrectly, it's probably too difficult to accurately analyze anyway.\n *\n * @param {Rule.Node} node\n * @returns {boolean}\n */\nexport const isUseEffect = (node) =>\n  node.type === \"CallExpression\" &&\n  ((node.callee.type === \"Identifier\" && node.callee.name === \"useEffect\") ||\n    (node.callee.type === \"MemberExpression\" &&\n      node.callee.object.name === \"React\" &&\n      node.callee.property.name === \"useEffect\"));\n\n/**\n * @param {Rule.Node} node - The `useEffect` `CallExpression` node\n * @returns {Rule.Node | undefined}\n */\nexport const getEffectFn = (node) => {\n  const effectFn = node.arguments[0];\n  if (\n    effectFn?.type !== \"ArrowFunctionExpression\" &&\n    effectFn?.type !== \"FunctionExpression\"\n  ) {\n    return undefined;\n  }\n\n  return effectFn;\n};\n\n/**\n * @param {Rule.RuleContext} context\n * @param {Rule.Node} node - The `useEffect` `CallExpression` node\n * @returns {Scope.Reference[] | undefined}\n */\nexport const getEffectFnRefs = (context, node) => {\n  const effectFn = getEffectFn(node);\n  return effectFn ? getDownstreamRefs(context, effectFn) : undefined;\n};\n\n/**\n * @param {Rule.RuleContext} context\n * @param {Rule.Node} node - The `useEffect` `CallExpression` node\n * @returns {Scope.Reference[] | undefined}\n */\nexport function getEffectDepsRefs(context, node) {\n  const depsArr = node.arguments[1];\n  if (depsArr?.type !== \"ArrayExpression\") {\n    return undefined;\n  }\n\n  return getDownstreamRefs(context, depsArr);\n}\n\n/**\n * @param {Rule.RuleContext} context\n * @param {Scope.Reference} ref\n * @returns {boolean} Whether this reference eventually calls a state setter function or a method on state.\n */\nexport const isStateSetterCall = (context, ref) =>\n  isEventualCallTo(context, ref, isStateSetter);\n\n/**\n * @param {Rule.RuleContext} context\n * @param {Scope.Reference} ref\n * @returns {boolean} Whether this reference eventually calls a prop function or a method on a prop.\n */\nexport const isPropCall = (context, ref) =>\n  isEventualCallTo(context, ref, isProp);\n\n/**\n * @param {Rule.RuleContext} context\n * @param {Scope.Reference} ref\n * @returns {boolean} Whether this reference eventually calls a method on a ref.\n */\nexport const isRefCall = (context, ref) =>\n  isEventualCallTo(context, ref, (ref) => isRefCurrent(ref) || isRef(ref));\n\n/**\n * @param context {Rule.RuleContext}\n * @param {Scope.Reference} ref\n * @returns {Rule.Node | undefined} The `VariableDeclarator` node of the `useState` call.\n */\nexport const getUseStateDecl = (context, ref) => {\n  let node = getUpstreamRefs(context, ref).find((ref) =>\n    isUseState(ref.identifier),\n  )?.identifier;\n  while (node && node.type !== \"VariableDeclarator\") {\n    node = node.parent;\n  }\n  return node;\n};\n\n/**\n * While it *could* be an anti-pattern or unnecessary, effects *are* meant to synchronize systems.\n * So we presume that a \"subscription effect\" is usually valid, or at least may be more readable.\n *\n * TODO: We might be able to use this more granularly, e.g. ignore state setters inside a subscription effect,\n * instead of ignoring the whole effect...? But it'd have to be more complicated, like also ignore the same state setters called in the body.\n *\n * @param {Rule.Node} node - The `useEffect` `CallExpression` node\n * @returns {boolean}\n */\nexport const hasCleanup = (node) => {\n  const effectFn = node.arguments[0];\n  return (\n    (effectFn.type === \"ArrowFunctionExpression\" ||\n      effectFn.type === \"FunctionExpression\") &&\n    effectFn.body.type === \"BlockStatement\" &&\n    effectFn.body.body.some(\n      (stmt) => stmt.type === \"ReturnStatement\" && stmt.argument,\n    )\n  );\n};\n", "import { isUseEffect, getEffectFnRefs } from \"../util/react.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow empty effects.\",\n    },\n    schema: [],\n    messages: {\n      avoidEmptyEffect: \"This effect is empty and could be removed.\",\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node)) return;\n\n      if (\n        node.arguments?.length === 0 ||\n        getEffectFnRefs(context, node)?.length === 0\n      ) {\n        // Hopefully it's obvious the effect can be removed.\n        // More a follow-up for once they fix/remove other issues.\n        context.report({\n          node,\n          messageId: \"avoidEmptyEffect\",\n        });\n      }\n    },\n  }),\n};\n", "import {\n  getArgsUpstreamRefs,\n  getCallExpr,\n  getUpstreamRefs,\n  isSynchronous,\n} from \"../util/ast.js\";\nimport {\n  getEffectDepsRefs,\n  getEffectFn,\n  getEffectFnRefs,\n  isProp,\n  isStateSetterCall,\n  isUseEffect,\n} from \"../util/react.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow adjusting state in an effect when a prop changes.\",\n      url: \"https://react.dev/learn/you-might-not-need-an-effect#adjusting-some-state-when-a-prop-changes\",\n    },\n    schema: [],\n    messages: {\n      avoidAdjustingStateWhenAPropChanges:\n        \"Avoid adjusting state when a prop changes. Instead, adjust the state directly during render, or refactor your state to avoid this need entirely.\",\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      const isSomeDepsProps = depsRefs\n        .flatMap((ref) => getUpstreamRefs(context, ref))\n        .some((ref) => isProp(ref));\n\n      effectFnRefs\n        .filter((ref) => isStateSetterCall(context, ref))\n        .filter((ref) => isSynchronous(ref.identifier, getEffectFn(node)))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n\n          // Avoid overlap with no-derived-state\n          const isSomeArgsProps = getArgsUpstreamRefs(context, ref).some(\n            (ref) => isProp(ref),\n          );\n\n          if (isSomeDepsProps && !isSomeArgsProps) {\n            context.report({\n              node: callExpr,\n              messageId: \"avoidAdjustingStateWhenAPropChanges\",\n            });\n          }\n        });\n    },\n  }),\n};\n", "import {\n  getCallExpr,\n  getDownstreamRefs,\n  getUpstreamRefs,\n} from \"../util/ast.js\";\nimport {\n  getEffectFnRefs,\n  getEffectDepsRefs,\n  isStateSetterCall,\n  isProp,\n  getUseStateDecl,\n  isReactFunctionalComponent,\n  isReactFunctionalHOC,\n  isCustomHook,\n  isState,\n  isUseEffect,\n} from \"../util/react.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description:\n        \"Disallow resetting all state in an effect when a prop changes.\",\n      url: \"https://react.dev/learn/you-might-not-need-an-effect#resetting-all-state-when-a-prop-changes\",\n    },\n    schema: [],\n    messages: {\n      avoidResettingAllStateWhenAPropChanges:\n        'Avoid resetting all state when a prop changes. If \"{{prop}}\" is a key, pass it as `key` instead so React will reset the component.',\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n      // Skip custom hooks because they can't receive `key` like components can.\n      const containingNode = findContainingNode(node);\n      if (containingNode && isCustomHook(containingNode)) return;\n\n      const propUsedToResetAllState = findPropUsedToResetAllState(\n        context,\n        effectFnRefs,\n        depsRefs,\n        node,\n      );\n\n      if (propUsedToResetAllState) {\n        context.report({\n          node: node,\n          messageId: \"avoidResettingAllStateWhenAPropChanges\",\n          data: { prop: propUsedToResetAllState.identifier.name },\n        });\n      }\n    },\n  }),\n};\n\nconst findPropUsedToResetAllState = (\n  context,\n  effectFnRefs,\n  depsRefs,\n  useEffectNode,\n) => {\n  const stateSetterRefs = effectFnRefs.filter((ref) =>\n    isStateSetterCall(context, ref),\n  );\n\n  const isAllStateReset =\n    stateSetterRefs.length > 0 &&\n    stateSetterRefs.every((ref) => isSetStateToInitialValue(context, ref)) &&\n    stateSetterRefs.length ===\n      countUseStates(context, findContainingNode(useEffectNode));\n\n  return isAllStateReset\n    ? depsRefs\n        .flatMap((ref) => getUpstreamRefs(context, ref))\n        .find((ref) => isProp(ref))\n    : undefined;\n};\n\nconst isSetStateToInitialValue = (context, setterRef) => {\n  const setStateToValue = getCallExpr(setterRef).arguments[0];\n  const stateInitialValue = getUseStateDecl(context, setterRef).init\n    .arguments[0];\n\n  // `useState()` (with no args) defaults to `undefined`,\n  // so ommitting the arg is equivalent to passing `undefined`.\n  // Technically this would false positive if they shadowed\n  // `undefined` in only one of the scopes (only possible via `var`),\n  // but I hope no one would do that.\n  const isUndefined = (node) => node === undefined || node.name === \"undefined\";\n  if (isUndefined(setStateToValue) && isUndefined(stateInitialValue)) {\n    return true;\n  }\n\n  // `sourceCode.getText()` returns the entire file when passed null/undefined - let's short circuit that\n  if (setStateToValue === null && stateInitialValue === null) {\n    return true;\n  } else if (\n    (setStateToValue && !stateInitialValue) ||\n    (!setStateToValue && stateInitialValue)\n  ) {\n    return false;\n  }\n\n  // TODO: This is one of the few times we compare just the immediate nodes,\n  // not upstream variables - that seems pretty complicated here?\n  // At the least, upstream functions would have to return literals for us to consider too, not just variables...\n  return (\n    context.sourceCode.getText(setStateToValue) ===\n    context.sourceCode.getText(stateInitialValue)\n  );\n};\n\nconst countUseStates = (context, componentNode) => {\n  if (!componentNode) {\n    return 0;\n  }\n\n  return getDownstreamRefs(context, componentNode).filter((ref) => isState(ref))\n    .length;\n};\n\n// Returns the component or custom hook that contains the `useEffect` node.\n// WARNING: Per the `isReactFunctionalComponent` etc. internals, this will return undefined for some non-idiomatic component definitions.\n// e.g. `function buildComponent(arg1, arg2) { return <div />; }`\n// Not sure we can account for that without introducing false positives, and those are rare and arguably bad practice.\nconst findContainingNode = (node) => {\n  if (!node) {\n    return undefined;\n  } else if (\n    isReactFunctionalComponent(node) ||\n    isReactFunctionalHOC(node) ||\n    isCustomHook(node)\n  ) {\n    return node;\n  } else {\n    return findContainingNode(node.parent);\n  }\n};\n", "import {\n  findDownstreamNodes,\n  getDownstreamRefs,\n  getUpstreamRefs,\n} from \"../util/ast.js\";\nimport {\n  getEffectFnRefs,\n  getEffectDepsRefs,\n  hasCleanup,\n  isState,\n  isUseEffect,\n} from \"../util/react.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow using state and an effect as an event handler.\",\n      url: \"https://react.dev/learn/you-might-not-need-an-effect#sharing-logic-between-event-handlers\",\n    },\n    schema: [],\n    messages: {\n      avoidEventHandler:\n        \"Avoid using state and effects as an event handler. Instead, call the event handling code directly when the event occurs.\",\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node) || hasCleanup(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      // TODO: Can we also flag this when the deps are internal, and the body calls internal stuff?\n      // That'd overlap with other rules though... maybe just useRefs?\n\n      findDownstreamNodes(context, node, \"IfStatement\")\n        .filter((ifNode) => !ifNode.alternate)\n        .filter((ifNode) =>\n          getDownstreamRefs(context, ifNode.test)\n            .flatMap((ref) => getUpstreamRefs(context, ref))\n            // TODO: Should flag props too, but maybe with a different message?\n            .some((ref) => isState(ref)),\n        )\n        .forEach((ifNode) => {\n          context.report({\n            node: ifNode.test,\n            messageId: \"avoidEventHandler\",\n          });\n        });\n    },\n  }),\n};\n", "import {\n  getArgsUpstreamRefs,\n  getCallExpr,\n  isSynchronous,\n} from \"../util/ast.js\";\nimport {\n  getEffectFnRefs,\n  getEffectDepsRefs,\n  isPropCall,\n  isState,\n  isUseEffect,\n  getEffectFn,\n} from \"../util/react.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description:\n        \"Disallow passing live state to parent components in an effect.\",\n      url: \"https://react.dev/learn/you-might-not-need-an-effect#notifying-parent-components-about-state-changes\",\n    },\n    schema: [],\n    messages: {\n      avoidPassingLiveStateToParent:\n        \"Avoid passing live state to parents in an effect. Instead, lift the state to the parent and pass it down to the child as a prop.\",\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      effectFnRefs\n        .filter((ref) => isPropCall(context, ref))\n        .filter((ref) => isSynchronous(ref.identifier, getEffectFn(node)))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n          const isStateInArgs = getArgsUpstreamRefs(context, ref).some((ref) =>\n            isState(ref),\n          );\n\n          if (isStateInArgs) {\n            context.report({\n              node: callExpr,\n              messageId: \"avoidPassingLiveStateToParent\",\n            });\n          }\n        });\n    },\n  }),\n};\n", "import { getCallExpr, isSynchronous } from \"../util/ast.js\";\nimport {\n  getEffectDepsRefs,\n  getEffectFn,\n  getEffectFnRefs,\n  getUseStateDecl,\n  isStateSetterCall,\n  isUseEffect,\n} from \"../util/react.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow initializing state in an effect.\",\n      url: \"https://tkdodo.eu/blog/avoiding-hydration-mismatches-with-use-sync-external-store\",\n    },\n    schema: [],\n    messages: {\n      avoidInitializingState:\n        'Avoid initializing state in an effect. Instead, initialize \"{{state}}\"\\'s `useState()` with \"{{arguments}}\". For SSR hydration, prefer `useSyncExternalStore()`.',\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      // TODO: Should this length check account for the setter in the deps? exhaustive-deps doesn't warn one way or the other\n      if (depsRefs.length > 0) return;\n\n      effectFnRefs\n        .filter((ref) => isStateSetterCall(context, ref))\n        .filter((ref) => isSynchronous(ref.identifier, getEffectFn(node)))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n          const useStateNode = getUseStateDecl(context, ref);\n          const stateName = (\n            useStateNode.id.elements[0] ?? useStateNode.id.elements[1]\n          )?.name;\n          const argumentText = callExpr.arguments[0]\n            ? context.sourceCode.getText(callExpr.arguments[0])\n            : \"undefined\";\n\n          context.report({\n            node: getCallExpr(ref),\n            messageId: \"avoidInitializingState\",\n            data: { state: stateName, arguments: argumentText },\n          });\n        });\n    },\n  }),\n};\n", "import {\n  getArgsUpstreamRefs,\n  getCallExpr,\n  getUpstreamRefs,\n  isSynchronous,\n} from \"../util/ast.js\";\nimport {\n  getEffectDepsRefs,\n  getEffectFnRefs,\n  hasCleanup,\n  isState,\n  isStateSetterCall,\n  isUseEffect,\n  getEffectFn,\n} from \"../util/react.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow chaining state changes in an effect.\",\n      url: \"https://react.dev/learn/you-might-not-need-an-effect#chains-of-computations\",\n    },\n    schema: [],\n    messages: {\n      avoidChainingStateUpdates:\n        \"Avoid chaining state changes. When possible, update all relevant state simultaneously.\",\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node) || hasCleanup(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      const isSomeDepsState = depsRefs\n        .flatMap((ref) => getUpstreamRefs(context, ref))\n        .some((ref) => isState(ref));\n\n      effectFnRefs\n        .filter((ref) => isStateSetterCall(context, ref))\n        .filter((ref) => isSynchronous(ref.identifier, getEffectFn(node)))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n\n          // Avoid overlap with no-derived-state\n          const isSomeArgsState = getArgsUpstreamRefs(context, ref).some(\n            (ref) => isState(ref),\n          );\n\n          if (isSomeDepsState && !isSomeArgsState) {\n            context.report({\n              node: callExpr,\n              messageId: \"avoidChainingStateUpdates\",\n            });\n          }\n        });\n    },\n  }),\n};\n", "import {\n  getArgsUpstreamRefs,\n  getCallExpr,\n  getUpstreamRefs,\n  isSynchronous,\n} from \"../util/ast.js\";\nimport {\n  getEffectFnRefs,\n  getEffectDepsRefs,\n  isStateSetterCall,\n  getUseStateDecl,\n  isProp,\n  hasCleanup,\n  isState,\n  isUseEffect,\n  getEffectFn,\n} from \"../util/react.js\";\n\n/**\n * @type {import('eslint').Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow storing derived state in an effect.\",\n      url: \"https://react.dev/learn/you-might-not-need-an-effect#updating-state-based-on-props-or-state\",\n    },\n    schema: [],\n    messages: {\n      avoidDerivedState:\n        'Avoid storing derived state. Compute \"{{state}}\" directly during render, optionally with `useMemo` if it\\'s expensive.',\n      avoidSingleSetter:\n        'Avoid storing derived state. \"{{state}}\" is only set here, and thus could be computed directly during render.',\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node) || hasCleanup(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      effectFnRefs\n        .filter((ref) => isStateSetterCall(context, ref))\n        .filter((ref) => isSynchronous(ref.identifier, getEffectFn(node)))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n          const useStateNode = getUseStateDecl(context, ref);\n          const stateName = (\n            useStateNode?.id.elements[0] ?? useStateNode?.id.elements[1]\n          )?.name;\n\n          const argsUpstreamRefs = getArgsUpstreamRefs(context, ref);\n          const depsUpstreamRefs = depsRefs.flatMap((ref) =>\n            getUpstreamRefs(context, ref),\n          );\n          const isSomeArgsInternal = argsUpstreamRefs.some(\n            (ref) => isState(ref) || isProp(ref),\n          );\n\n          const isAllArgsInDeps =\n            argsUpstreamRefs.length &&\n            argsUpstreamRefs.every((argRef) =>\n              depsUpstreamRefs.some(\n                (depRef) => argRef.resolved == depRef.resolved,\n              ),\n            );\n          const isValueAlwaysInSync = isAllArgsInDeps && countCalls(ref) === 1;\n\n          if (isSomeArgsInternal) {\n            context.report({\n              node: callExpr,\n              messageId: \"avoidDerivedState\",\n              data: { state: stateName },\n            });\n          } else if (isValueAlwaysInSync) {\n            context.report({\n              node: callExpr,\n              messageId: \"avoidSingleSetter\",\n              data: { state: stateName },\n            });\n          }\n        });\n    },\n  }),\n};\n\nconst countCalls = (ref) =>\n  ref.resolved.references.filter(\n    (ref) => ref.identifier.parent.type === \"CallExpression\",\n  ).length;\n", "import {\n  getCallExpr,\n  getDownstreamRefs,\n  getUpstreamRefs,\n  isSynchronous,\n} from \"../util/ast.js\";\nimport {\n  getEffectFnRefs,\n  getEffectDepsRefs,\n  isPropCall,\n  isConstant,\n  isRefCurrent,\n  isUseState,\n  isUseRef,\n  isProp,\n  hasCleanup,\n  isUseEffect,\n  isRefCall,\n  getEffectFn,\n} from \"../util/react.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow passing data to parents in an effect.\",\n      url: \"https://react.dev/learn/you-might-not-need-an-effect#passing-data-to-the-parent\",\n    },\n    schema: [],\n    messages: {\n      avoidPassingDataToParent:\n        \"Avoid passing data to parents in an effect. Instead, let the parent fetch the data itself and pass it down to the child as a prop.\",\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node) || hasCleanup(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      effectFnRefs\n        .filter((ref) => isPropCall(context, ref))\n        .filter((ref) => !isRefCall(context, ref))\n        .filter((ref) => isSynchronous(ref.identifier, getEffectFn(node)))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n\n          const argsUpstreamRefs = getUpstreamRefs(context, ref)\n            .map((ref) => getCallExpr(ref))\n            .filter(Boolean)\n            .flatMap((callExpr) => callExpr.arguments)\n            .flatMap((arg) => getDownstreamRefs(context, arg))\n            // Leaf because our \"is data\" check is essentially \"is not all this other stuff\",\n            // and the \"other stuff\" only works on leaf nodes.\n            // Mid-stream nodes are effectively nothing, and so would pass those.\n            // TODO: DIYing getArgsUpstreamRefs for that reason.\n            .flatMap((ref) => getUpstreamRefs(context, ref, \"leaf\"));\n          const isSomeArgsData = argsUpstreamRefs.some(\n            (ref) =>\n              // TODO: Ideally would use isState and isRef, not the hooks.\n              // But because it goes to leaves. Must be some other way?\n              !isUseState(ref.identifier) &&\n              !isProp(ref) &&\n              !isUseRef(ref) &&\n              !isRefCurrent(ref) &&\n              !isConstant(ref),\n          );\n\n          if (isSomeArgsData) {\n            context.report({\n              node: callExpr,\n              messageId: \"avoidPassingDataToParent\",\n            });\n          }\n        });\n    },\n  }),\n};\n", "import { getArgsUpstreamRefs, getCallExpr } from \"../util/ast.js\";\nimport {\n  getEffectFnRefs,\n  getEffectDepsRefs,\n  isPropCall,\n  isRef,\n  hasCleanup,\n  isUseEffect,\n  isRefCall,\n} from \"../util/react.js\";\n\n/**\n * @type {import(\"eslint\").Rule.RuleModule}\n */\nexport default {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description:\n        \"Disallow passing refs, or data from callbacks registered on them, to parents in an effect. Use `forwardRef` instead.\",\n      url: \"https://react.dev/reference/react/forwardRef\",\n    },\n    schema: [],\n    messages: {\n      avoidPassingRefToParent:\n        \"Avoid passing refs to parents in an effect. Use `forwardRef` instead.\",\n      avoidPropCallbackInRefCallback:\n        \"Avoid calling props inside callbacks registered on refs in an effect. Use `forwardRef` to register the callback in the parent instead.\",\n      avoidReceivingRefFromParent:\n        \"Avoid receiving refs from parents to use in an effect. Use `forwardRef` instead.\",\n    },\n  },\n  create: (context) => ({\n    CallExpression: (node) => {\n      if (!isUseEffect(node) || hasCleanup(node)) return;\n      const effectFnRefs = getEffectFnRefs(context, node);\n      const depsRefs = getEffectDepsRefs(context, node);\n      if (!effectFnRefs || !depsRefs) return;\n\n      effectFnRefs\n        .filter((ref) => isPropCall(context, ref))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n\n          const hasRefArg = getArgsUpstreamRefs(context, ref).some((ref) =>\n            isRef(ref),\n          );\n\n          if (hasRefArg) {\n            context.report({\n              node: callExpr,\n              messageId: \"avoidPassingRefToParent\",\n            });\n          }\n        });\n\n      effectFnRefs\n        .filter((ref) => isRefCall(context, ref))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n\n          const passesDataToParent = getArgsUpstreamRefs(context, ref).some(\n            (ref) => isPropCall(context, ref),\n          );\n\n          if (passesDataToParent) {\n            context.report({\n              node: callExpr,\n              messageId: \"avoidPropCallbackInRefCallback\",\n            });\n          }\n        });\n\n      effectFnRefs\n        .filter((ref) => isPropCall(context, ref) && isRefCall(context, ref))\n        .forEach((ref) => {\n          const callExpr = getCallExpr(ref);\n\n          context.report({\n            node: callExpr,\n            messageId: \"avoidReceivingRefFromParent\",\n          });\n        });\n    },\n  }),\n};\n", "import noEmptyEffect from \"./rules/no-empty-effect.js\";\nimport noAdjustStateOnPropChange from \"./rules/no-adjust-state-on-prop-change.js\";\nimport noResetAllStateOnPropChange from \"./rules/no-reset-all-state-on-prop-change.js\";\nimport noEventHandler from \"./rules/no-event-handler.js\";\nimport noPassLiveStateToParent from \"./rules/no-pass-live-state-to-parent.js\";\nimport noInitializeState from \"./rules/no-initialize-state.js\";\nimport noChainStateUpdates from \"./rules/no-chain-state-updates.js\";\nimport noDerivedState from \"./rules/no-derived-state.js\";\nimport noPassDataToParent from \"./rules/no-pass-data-to-parent.js\";\nimport noPassRefToParent from \"./rules/no-pass-ref-to-parent.js\";\nimport globals from \"globals\";\n\n/**\n * @type {import(\"eslint\").ESLint.Plugin}\n */\nconst plugin = {\n  meta: {\n    name: \"react-you-might-not-need-an-effect\",\n  },\n  configs: {},\n  rules: {\n    \"no-empty-effect\": noEmptyEffect,\n    \"no-adjust-state-on-prop-change\": noAdjustStateOnPropChange,\n    \"no-reset-all-state-on-prop-change\": noResetAllStateOnPropChange,\n    \"no-event-handler\": noEventHandler,\n    \"no-pass-live-state-to-parent\": noPassLiveStateToParent,\n    \"no-pass-data-to-parent\": noPassDataToParent,\n    \"no-pass-ref-to-parent\": noPassRefToParent,\n    \"no-initialize-state\": noInitializeState,\n    \"no-chain-state-updates\": noChainStateUpdates,\n    \"no-derived-state\": noDerivedState,\n  },\n};\n\nconst recommendedRules = Object.keys(plugin.rules).reduce((acc, ruleName) => {\n  acc[plugin.meta.name + \"/\" + ruleName] = \"warn\";\n  return acc;\n}, {});\nconst languageOptions = {\n  globals: {\n    // Required so we can resolve global references to their upstream global variables\n    ...globals.browser,\n  },\n  parserOptions: {\n    ecmaFeatures: {\n      jsx: true,\n    },\n  },\n};\n\nObject.assign(plugin.configs, {\n  // flat config format\n  recommended: {\n    files: [\"**/*.{js,jsx,mjs,cjs,ts,tsx,mts,cts}\"],\n    plugins: {\n      // Object.assign above so we can reference `plugin` here\n      [plugin.meta.name]: plugin,\n    },\n    rules: recommendedRules,\n    languageOptions,\n  },\n  \"legacy-recommended\": {\n    plugins: [plugin.meta.name],\n    rules: recommendedRules,\n    ...languageOptions,\n  },\n});\n\nexport default plugin;\n", "// `build.js` will bundle everything into CJS.\n// Would be nice to have it use `index.js` directly, but then `esbuild`\n// seems unable to structure the CJS export the way ESLint expects.\n// Seems we have to unwrap the default export ourselves for that.\nmodule.exports = require(\"./index.js\").default;\n"],
  "mappings": "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",
  "names": ["ref", "ref", "ref", "ref", "ref", "ref", "ref", "callExpr", "ref", "globals"]
}
